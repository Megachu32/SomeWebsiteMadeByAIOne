<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Hierarchy Tree Converter (Smart Crop)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --node-bg: #4CAF50;
            --node-text: white;
            --line-color: #666;
            --danger: #f44336;
            --primary: #2196F3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { color: #333; }

        .controls {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }

        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box;
        }

        .note {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
            background: #fff3cd;
            padding: 5px;
            border-left: 3px solid #ffc107;
        }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn-generate { background-color: var(--primary); color: white; }
        .btn-generate:hover { background-color: #1976D2; }
        .btn-download { background-color: #FF9800; color: white; }
        .btn-download:hover { background-color: #F57C00; }

        .file-upload { position: relative; overflow: hidden; display: inline-block; }
        .btn-ocr { background-color: #9C27B0; color: white; }
        .btn-ocr:hover { background-color: #7B1FA2; }
        .file-upload input[type=file] {
            font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer;
        }

        /* Tree Area */
        #tree-wrapper {
            width: 100%;
            overflow: auto;
            border: 1px solid #ccc;
            background: white;
            padding: 40px;
            position: relative;
            min-height: 400px;
            display: flex;
            justify-content: center;
        }

        .tree-container { position: relative; }

        .node {
            position: absolute;
            width: 80px;
            height: 40px;
            background-color: var(--node-bg);
            color: var(--node-text);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            user-select: none;
        }

        .node:hover { transform: scale(1.05); background-color: #43a047; }
        .node.null-node {
            background-color: #eee; color: #999; border: 1px dashed #bbb; box-shadow: none; font-style: italic;
        }

        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        line { stroke: var(--line-color); stroke-width: 2; }

        /* --- POPUP MODAL STYLES --- */
        #nodeModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title { font-weight: bold; font-size: 1.2em; }
        
        .btn-trash {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--danger);
            padding: 0;
        }
        .btn-trash:hover { color: #d32f2f; transform: scale(1.1); }

        .modal-body input {
            width: 100%;
            padding: 8px;
            margin-bottom: 20px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            text-align: center;
        }

        .child-controls {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .child-btn {
            flex: 1;
            padding: 10px;
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .btn-add-child { background-color: #2196F3; } 
        .btn-remove-child { background-color: #FF9800; } 
        
        .btn-close {
            margin-top: 15px;
            background-color: #999;
            color: white;
            width: 100%;
        }

    </style>
</head>
<body>

    <h1>Hierarchy Tree Generator</h1>

    <div class="controls">
        <div class="input-group">
            <label>Input Struktur Tree:</label>
            <div class="note">
                <strong>Format:</strong> {Nama {Kiri, Kanan}} <br>
                <strong>Aturan:</strong> Gunakan "null" untuk cabang kosong. Gunakan "\null" jika ingin menamai node dengan kata "null".
            </div>
            <textarea id="inputData">{Root {Child A {Leaf 1{null}, Leaf 2{null}}, Child B {Leaf 3 {Null}, Null}}}</textarea>
        </div>

        <div class="btn-group">
            <button class="btn-generate" onclick="generateTree()">Generate Tree</button>
            <div class="file-upload">
                <button class="btn-ocr">‚úö Img to Text</button>
                <input type="file" accept="image/*" onchange="mockOCR(this)">
            </div>
            <button class="btn-download" onclick="downloadTree()">Download (.png)</button>
        </div>
    </div>

    <div id="tree-wrapper">
        <div id="tree-canvas" class="tree-container"></div>
    </div>

    <!-- POPUP MODAL -->
    <div id="nodeModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Edit Node</span>
                <button class="btn-trash" onclick="deleteCurrentNode()" title="Hapus Node Ini">üóëÔ∏è</button>
            </div>
            
            <div class="modal-body">
                <label>Nama Variable:</label>
                <input type="text" id="nodeNameInput" placeholder="Nama Node">
                
                <label>Kelola Child:</label>
                <div class="child-controls">
                    <button id="btnLeft" class="child-btn" onclick="toggleLeft()">‚¨ÖÔ∏è Kiri</button>
                    <button id="btnRight" class="child-btn" onclick="toggleRight()">Kanan ‚û°Ô∏è</button>
                </div>
            </div>

            <button class="btn-close" onclick="closeModal()">Tutup / Simpan Nama</button>
        </div>
    </div>

    <script>
        class TreeNode {
            constructor(name, left = null, right = null) {
                this.name = name;
                this.left = left;
                this.right = right;
                this.parent = null; 
                this.x = 0;
                this.y = 0;
            }
        }

        let rootNode = null;
        let selectedNode = null; 
        const LEVEL_HEIGHT = 80;

        // --- Parser Logic ---

        function splitContent(str) {
            let depth = 0;
            let splitIndex = -1;
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '{') depth++;
                else if (str[i] === '}') depth--;
                else if (str[i] === ',' && depth === 0) {
                    splitIndex = i;
                    break;
                }
            }
            if (splitIndex === -1) return [str.trim()]; 
            return [str.substring(0, splitIndex).trim(), str.substring(splitIndex + 1).trim()];
        }

        function parseString(str) {
            str = str.trim();
            if (str.startsWith('{') && str.endsWith('}')) {
                str = str.substring(1, str.length - 1).trim();
            } else { if(!str) return null; }

            let firstBrace = str.indexOf('{');
            if (firstBrace === -1) {
                let cleanName = str.trim();
                if (cleanName.toLowerCase() === 'null') return null;
                if (cleanName.toLowerCase() === '\\null') return new TreeNode('null');
                return new TreeNode(cleanName);
            }

            let namePart = str.substring(0, firstBrace).trim();
            let childrenPart = str.substring(firstBrace + 1, str.lastIndexOf('}')).trim();

            if (namePart.toLowerCase() === 'null') return null;
            let finalName = namePart;
            if (finalName.startsWith('\\')) finalName = finalName.substring(1);

            let node = new TreeNode(finalName);

            if (childrenPart.toLowerCase() === 'null') {
                node.left = null; node.right = null;
            } else {
                let parts = splitContent(childrenPart);
                if (parts.length >= 1) node.left = parseString(parts[0]);
                if (parts.length >= 2) node.right = parseString(parts[1]);
            }
            return node;
        }

        function addParentPointers(node, parent = null) {
            if (!node) return;
            node.parent = parent;
            addParentPointers(node.left, node);
            addParentPointers(node.right, node);
        }

        // --- Layout & Render Logic ---

        function getDepth(node) {
            if (!node) return 0;
            return 1 + Math.max(getDepth(node.left), getDepth(node.right));
        }

        function assignCoordinates(node, x, y, horizontalSpacing) {
            if (!node) return;
            node.x = x;
            node.y = y;
            if (node.left) assignCoordinates(node.left, x - horizontalSpacing, y + LEVEL_HEIGHT, horizontalSpacing / 2);
            if (node.right) assignCoordinates(node.right, x + horizontalSpacing, y + LEVEL_HEIGHT, horizontalSpacing / 2);
        }

        function generateTree(skipParse = false) {
            if (!skipParse) {
                const input = document.getElementById('inputData').value;
                try {
                    rootNode = parseString(input);
                    if (!rootNode) throw new Error("Root is null");
                } catch (e) {
                    document.getElementById('tree-canvas').innerHTML = '';
                    rootNode = null;
                    return;
                }
            }

            addParentPointers(rootNode);
            updateInputFromTree();

            const canvas = document.getElementById('tree-canvas');
            canvas.innerHTML = '';
            
            if (!rootNode) return;

            const maxDepth = getDepth(rootNode);
            const initialSpacing = Math.pow(2, maxDepth - 2) * 70; 
            const totalWidth = Math.max(800, initialSpacing * 4);
            const totalHeight = (maxDepth * LEVEL_HEIGHT) + 100;
            
            canvas.style.width = totalWidth + 'px';
            canvas.style.height = totalHeight + 'px';

            assignCoordinates(rootNode, totalWidth / 2, 40, initialSpacing);

            let svgHTML = `<svg width="${totalWidth}" height="${totalHeight}">`;
            svgHTML += drawLinesRecursive(rootNode);
            svgHTML += `</svg>`;
            canvas.innerHTML = svgHTML;

            drawNodesRecursive(rootNode, canvas);
        }

        function drawLinesRecursive(node) {
            if (!node) return '';
            let lines = '';
            if (node.left) {
                lines += `<line x1="${node.x}" y1="${node.y}" x2="${node.left.x}" y2="${node.left.y}" />`;
                lines += drawLinesRecursive(node.left);
            }
            if (node.right) {
                lines += `<line x1="${node.x}" y1="${node.y}" x2="${node.right.x}" y2="${node.right.y}" />`;
                lines += drawLinesRecursive(node.right);
            }
            return lines;
        }

        function drawNodesRecursive(node, container) {
            if (!node) return;

            const div = document.createElement('div');
            div.className = 'node';
            div.style.left = (node.x - 40) + 'px';
            div.style.top = (node.y - 20) + 'px';
            div.innerText = node.name;
            
            div.onclick = function(e) {
                e.stopPropagation();
                openModal(node);
            };

            container.appendChild(div);
            drawNodesRecursive(node.left, container);
            drawNodesRecursive(node.right, container);
        }

        // --- MODAL & INTERACTION LOGIC ---

        const modal = document.getElementById('nodeModal');
        const nameInput = document.getElementById('nodeNameInput');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        function openModal(node) {
            selectedNode = node;
            nameInput.value = node.name;
            updateModalButtons();
            modal.style.display = 'flex';
            nameInput.focus();
        }

        function updateModalButtons() {
            if (selectedNode.left) {
                btnLeft.innerHTML = "‚¨ÖÔ∏è Hapus Kiri";
                btnLeft.className = "child-btn btn-remove-child";
                btnLeft.title = "Ubah Child Kiri jadi Null";
            } else {
                btnLeft.innerHTML = "‚¨ÖÔ∏è Buat Kiri";
                btnLeft.className = "child-btn btn-add-child";
                btnLeft.title = "Generate Node Baru";
            }

            if (selectedNode.right) {
                btnRight.innerHTML = "Hapus Kanan ‚û°Ô∏è";
                btnRight.className = "child-btn btn-remove-child";
                btnRight.title = "Ubah Child Kanan jadi Null";
            } else {
                btnRight.innerHTML = "Buat Kanan ‚û°Ô∏è";
                btnRight.className = "child-btn btn-add-child";
                btnRight.title = "Generate Node Baru";
            }
        }

        function closeModal() {
            if (selectedNode) {
                const newName = nameInput.value.trim();
                if (newName) selectedNode.name = newName;
            }
            modal.style.display = 'none';
            selectedNode = null;
            generateTree(true); 
        }

        function deleteCurrentNode() {
            if (!selectedNode) return;
            const confirmDelete = confirm(`Hapus node "${selectedNode.name}" beserta semua anaknya?`);
            if (!confirmDelete) return;

            if (selectedNode.parent) {
                if (selectedNode.parent.left === selectedNode) {
                    selectedNode.parent.left = null;
                } else if (selectedNode.parent.right === selectedNode) {
                    selectedNode.parent.right = null;
                }
            } else {
                rootNode = null;
            }
            modal.style.display = 'none';
            selectedNode = null;
            generateTree(true);
        }

        function toggleLeft() {
            if (!selectedNode) return;
            if (selectedNode.left) {
                if(confirm("Ubah child kiri menjadi Null?")) {
                    selectedNode.left = null;
                    updateModalButtons();
                }
            } else {
                const name = prompt("Masukkan nama untuk Node Kiri baru:", "NewNode");
                if (name) {
                    selectedNode.left = new TreeNode(name);
                    selectedNode.left.parent = selectedNode;
                    updateModalButtons();
                }
            }
        }

        function toggleRight() {
            if (!selectedNode) return;
            if (selectedNode.right) {
                if(confirm("Ubah child kanan menjadi Null?")) {
                    selectedNode.right = null;
                    updateModalButtons();
                }
            } else {
                const name = prompt("Masukkan nama untuk Node Kanan baru:", "NewNode");
                if (name) {
                    selectedNode.right = new TreeNode(name);
                    selectedNode.right.parent = selectedNode;
                    updateModalButtons();
                }
            }
        }
        
        nameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') closeModal();
        });

        // --- Utilities ---

        function updateInputFromTree() {
            const str = serializeTree(rootNode);
            document.getElementById('inputData').value = str;
        }

        function serializeTree(node) {
            if (!node) return 'Null';
            let name = node.name;
            if (name.toLowerCase() === 'null') name = '\\null';

            if (!node.left && !node.right) {
                return `{${name} {null}}`;
            }

            let leftStr = node.left ? serializeTree(node.left) : 'Null';
            let rightStr = node.right ? serializeTree(node.right) : 'Null';

            return `{${name} {${leftStr}, ${rightStr}}}`;
        }

        function mockOCR(fileInput) {
            if (fileInput.files && fileInput.files[0]) {
                const btn = document.querySelector('.btn-ocr');
                const originalText = btn.innerText;
                btn.innerText = "Processing...";
                setTimeout(() => {
                    const mockResult = "{RootOCR {Data A {Value 1{null}, Value 2{null}}, Data B {ImageNode {Null}, Null}}}";
                    document.getElementById('inputData').value = mockResult;
                    alert("Gambar berhasil diproses menjadi teks! (Simulasi)");
                    btn.innerText = originalText;
                    fileInput.value = "";
                    generateTree(); 
                }, 1500);
            }
        }

        // --- NEW DOWNLOAD LOGIC ---

        function downloadTree() {
            const container = document.getElementById('tree-canvas');
            const nodes = document.querySelectorAll('.node');
            
            if (nodes.length === 0) {
                alert("Tidak ada tree untuk didownload.");
                return;
            }

            // 1. Hitung Bounding Box dari seluruh elemen Node yang ada
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            nodes.forEach(node => {
                // style.left/top diset sebagai string '123px', kita parse ke float
                // style.left di program ini adalah posisi pojok kiri node (x - 40)
                const left = parseFloat(node.style.left);
                const top = parseFloat(node.style.top);
                const width = node.offsetWidth;   // Harusnya 80
                const height = node.offsetHeight; // Harusnya 40

                if (left < minX) minX = left;
                if (top < minY) minY = top;
                
                if ((left + width) > maxX) maxX = left + width;
                if ((top + height) > maxY) maxY = top + height;
            });

            // 2. Tambahkan Margin 10px dari sisi terluar
            const margin = 10;
            const cropX = minX - margin;
            const cropY = minY - margin;
            const cropWidth = (maxX - minX) + (margin * 2);
            const cropHeight = (maxY - minY) + (margin * 2);

            // 3. Download hanya area yang dihitung
            html2canvas(container, {
                backgroundColor: "#ffffff",
                scale: 2, // Biar tidak buram
                x: cropX,
                y: cropY,
                width: cropWidth,
                height: cropHeight,
                scrollX: 0,
                scrollY: 0
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = 'hierarchy-tree.png';
                link.href = canvas.toDataURL("image/png");
                link.click();
            });
        }

        window.onclick = function(event) {
            if (event.target == modal) closeModal();
        }

        window.onload = function() {
            generateTree();
        };

    </script>
</body>
</html>